(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 385:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  compare: () => (/* reexport */ compare),
  compareVersions: () => (/* reexport */ compareVersions),
  satisfies: () => (/* reexport */ satisfies),
  validate: () => (/* reexport */ validate),
  validateStrict: () => (/* reexport */ validateStrict)
});

;// CONCATENATED MODULE: ./node_modules/compare-versions/lib/esm/utils.js
const semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
const validateAndParse = (version) => {
    if (typeof version !== 'string') {
        throw new TypeError('Invalid argument expected string');
    }
    const match = version.match(semver);
    if (!match) {
        throw new Error(`Invalid argument not valid semver ('${version}' received)`);
    }
    match.shift();
    return match;
};
const isWildcard = (s) => s === '*' || s === 'x' || s === 'X';
const tryParse = (v) => {
    const n = parseInt(v, 10);
    return isNaN(n) ? v : n;
};
const forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];
const compareStrings = (a, b) => {
    if (isWildcard(a) || isWildcard(b))
        return 0;
    const [ap, bp] = forceType(tryParse(a), tryParse(b));
    if (ap > bp)
        return 1;
    if (ap < bp)
        return -1;
    return 0;
};
const compareSegments = (a, b) => {
    for (let i = 0; i < Math.max(a.length, b.length); i++) {
        const r = compareStrings(a[i] || '0', b[i] || '0');
        if (r !== 0)
            return r;
    }
    return 0;
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/compare-versions/lib/esm/compareVersions.js

/**
 * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.
 * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.
 * @param v1 - First version to compare
 * @param v2 - Second version to compare
 * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).
 */
const compareVersions = (v1, v2) => {
    // validate input and split into segments
    const n1 = validateAndParse(v1);
    const n2 = validateAndParse(v2);
    // pop off the patch
    const p1 = n1.pop();
    const p2 = n2.pop();
    // validate numbers
    const r = compareSegments(n1, n2);
    if (r !== 0)
        return r;
    // validate pre-release
    if (p1 && p2) {
        return compareSegments(p1.split('.'), p2.split('.'));
    }
    else if (p1 || p2) {
        return p1 ? -1 : 1;
    }
    return 0;
};
//# sourceMappingURL=compareVersions.js.map
;// CONCATENATED MODULE: ./node_modules/compare-versions/lib/esm/compare.js

/**
 * Compare [semver](https://semver.org/) version strings using the specified operator.
 *
 * @param v1 First version to compare
 * @param v2 Second version to compare
 * @param operator Allowed arithmetic operator to use
 * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.
 *
 * @example
 * ```
 * compare('10.1.8', '10.0.4', '>'); // return true
 * compare('10.0.1', '10.0.1', '='); // return true
 * compare('10.1.1', '10.2.2', '<'); // return true
 * compare('10.1.1', '10.2.2', '<='); // return true
 * compare('10.1.1', '10.2.2', '>='); // return false
 * ```
 */
const compare = (v1, v2, operator) => {
    // validate input operator
    assertValidOperator(operator);
    // since result of compareVersions can only be -1 or 0 or 1
    // a simple map can be used to replace switch
    const res = compareVersions(v1, v2);
    return operatorResMap[operator].includes(res);
};
const operatorResMap = {
    '>': [1],
    '>=': [0, 1],
    '=': [0],
    '<=': [-1, 0],
    '<': [-1],
    '!=': [-1, 1],
};
const allowedOperators = Object.keys(operatorResMap);
const assertValidOperator = (op) => {
    if (typeof op !== 'string') {
        throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);
    }
    if (allowedOperators.indexOf(op) === -1) {
        throw new Error(`Invalid operator, expected one of ${allowedOperators.join('|')}`);
    }
};
//# sourceMappingURL=compare.js.map
;// CONCATENATED MODULE: ./node_modules/compare-versions/lib/esm/satisfies.js


/**
 * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.
 *
 * @param version Version number to match
 * @param range Range pattern for version
 * @returns `true` if the version number is within the range, `false` otherwise.
 *
 * @example
 * ```
 * satisfies('1.1.0', '^1.0.0'); // return true
 * satisfies('1.1.0', '~1.0.0'); // return false
 * ```
 */
const satisfies = (version, range) => {
    // clean input
    range = range.replace(/([><=]+)\s+/g, '$1');
    // handle multiple comparators
    if (range.includes('||')) {
        return range.split('||').some((r) => satisfies(version, r));
    }
    else if (range.includes(' - ')) {
        const [a, b] = range.split(' - ', 2);
        return satisfies(version, `>=${a} <=${b}`);
    }
    else if (range.includes(' ')) {
        return range
            .trim()
            .replace(/\s{2,}/g, ' ')
            .split(' ')
            .every((r) => satisfies(version, r));
    }
    // if no range operator then "="
    const m = range.match(/^([<>=~^]+)/);
    const op = m ? m[1] : '=';
    // if gt/lt/eq then operator compare
    if (op !== '^' && op !== '~')
        return compare(version, range, op);
    // else range of either "~" or "^" is assumed
    const [v1, v2, v3, , vp] = validateAndParse(version);
    const [r1, r2, r3, , rp] = validateAndParse(range);
    const v = [v1, v2, v3];
    const r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x'];
    // validate pre-release
    if (rp) {
        if (!vp)
            return false;
        if (compareSegments(v, r) !== 0)
            return false;
        if (compareSegments(vp.split('.'), rp.split('.')) === -1)
            return false;
    }
    // first non-zero number
    const nonZero = r.findIndex((v) => v !== '0') + 1;
    // pointer to where segments can be >=
    const i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1;
    // before pointer must be equal
    if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0)
        return false;
    // after pointer must be >=
    if (compareSegments(v.slice(i), r.slice(i)) === -1)
        return false;
    return true;
};
//# sourceMappingURL=satisfies.js.map
;// CONCATENATED MODULE: ./node_modules/compare-versions/lib/esm/validate.js

/**
 * Validate [semver](https://semver.org/) version strings.
 *
 * @param version Version number to validate
 * @returns `true` if the version number is a valid semver version number, `false` otherwise.
 *
 * @example
 * ```
 * validate('1.0.0-rc.1'); // return true
 * validate('1.0-rc.1'); // return false
 * validate('foo'); // return false
 * ```
 */
const validate = (version) => typeof version === 'string' && /^[v\d]/.test(version) && semver.test(version);
/**
 * Validate [semver](https://semver.org/) version strings strictly. Will not accept wildcards and version ranges.
 *
 * @param version Version number to validate
 * @returns `true` if the version number is a valid semver version number `false` otherwise
 *
 * @example
 * ```
 * validate('1.0.0-rc.1'); // return true
 * validate('1.0-rc.1'); // return false
 * validate('foo'); // return false
 * ```
 */
const validateStrict = (version) => typeof version === 'string' &&
    /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/.test(version);
//# sourceMappingURL=validate.js.map
;// CONCATENATED MODULE: ./node_modules/compare-versions/lib/esm/index.js




//# sourceMappingURL=index.js.map

/***/ }),

/***/ 252:
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst


  var envHasBigInt64Array = typeof BigInt64Array !== 'undefined';


module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }


    if ((a instanceof Map) && (b instanceof Map)) {
      if (a.size !== b.size) return false;
      for (i of a.entries())
        if (!b.has(i[0])) return false;
      for (i of a.entries())
        if (!equal(i[1], b.get(i[0]))) return false;
      return true;
    }

    if ((a instanceof Set) && (b instanceof Set)) {
      if (a.size !== b.size) return false;
      for (i of a.entries())
        if (!b.has(i[0])) return false;
      return true;
    }

    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (a[i] !== b[i]) return false;
      return true;
    }


    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ 803:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Migrations
const MigrateCapabilities = __webpack_require__(206);
const MigrateCollections = __webpack_require__(899);
const MigrateProcesses = __webpack_require__(327);
// Processes
const ProcessDataType = __webpack_require__(809);
const ProcessParameter = __webpack_require__(578);
const ProcessSchema = __webpack_require__(570);
const ProcessUtils = __webpack_require__(464);
const ProcessRegistry = __webpack_require__(502);
// Others
const Versions = __webpack_require__(855);
const Utils = __webpack_require__(413);

module.exports = {
	MigrateCapabilities,
	MigrateCollections,
	MigrateProcesses,
	ProcessDataType,
	ProcessParameter,
	ProcessSchema,
	ProcessUtils,
	ProcessRegistry,
	Versions,
	Utils,
};

/***/ }),

/***/ 206:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Utils = __webpack_require__(413);
const Versions = __webpack_require__(855);
const MigrateCommons = __webpack_require__(332);

const NO_VERSION = "0.0.0";

/** Migrate capabilities related responses to the latest version. */
class MigrateCapabilities {

    /**
     * Tries to determine the API version from the capabilities object.
     * 
     * Returns the version number, e.g. "0.4.2", "1.0.0" or "0.0.0" (if unknown).
     * 
     * @param {object} capabilities 
     * @returns {string}
     */
    static guessApiVersion(capabilities) {
        // No object passed
        if (!Utils.isObject(capabilities)) {
            return NO_VERSION;
        }

        // Get exact info from version fields
        if (Versions.validate(capabilities.api_version)) {
            return capabilities.api_version;
        }
        else if (Versions.validate(capabilities.version)) {
            return capabilities.version;
        }
        // Now we are really guessing
        else if (Array.isArray(capabilities.endpoints)) {
            if (capabilities.endpoints.find(e => e.path === '/file_formats' || e.path === '/conformance' || e.path === '/files')) {
                return "1.0.0";
            }
            else if (capabilities.endpoints.find(e => e.path === '/output_formats' || e.path === '/files/{user_id}')) {
                return "0.4.2";
            }
            else if (!capabilities.backend_version && !capabilities.title && !capabilities.description && !capabilities.links) {
                return "0.3.1";
            }
        }

        // Can't determine version
        return NO_VERSION;
    }

    /**
     * Converts a `GET /` response to the latest version.
     * 
     * Always returns a deep copy of the input object.
     * 
     * @param {object} response - The response to convert
     * @param {string|null} version - Version number of the API, which the response conforms to. If `null`, tries to guess the version with `guessApiVersion()`.
     * @param {boolean} updateVersionNumbers - Should version numbers in the response be updated?
     * @param {boolean} updateEndpointPaths - Should the endpoint paths be updated to their recent equivalents?
     * @param {string} id - If no id is set in the response, sets it to the value specified here. Defaults to `unknown`.
     * @param {string} title - If no title is set in the response, sets it to the value specified here. Defaults to `Unknown`.
     * @param {string} title - If no backend_version is set in the response, sets it to the value specified here. Defaults to `0.0.0`.
     * @returns {object}
     */
    static convertCapabilitiesToLatestSpec(originalCapabilities, version = null, updateVersionNumbers = true, updateEndpointPaths = true, id = "unknown", title = "Unknown", backend_version = "0.0.0") {
        if (version === null) {
            version = this.guessApiVersion(originalCapabilities);
        }
        // Return empty if version number is not available
        if (version === NO_VERSION) {
            return {};
        }

        if (Versions.compare(version, "0.3.x", "<=")) {
            throw "Migrating from API version 0.3.0 and older is not supported.";
        }

        let capabilities = Utils.deepClone(originalCapabilities);
        // Fill & Update version number
        if (!updateVersionNumbers) {
            capabilities.api_version = version;
        }
        else {
            capabilities.api_version = "1.0.0";
        }

        // Convert billing plans
        if (Utils.isObject(capabilities.billing)) {
            capabilities.billing = this.convertBillingToLatestSpec(capabilities.billing, version);
        }
        else {
            delete capabilities.billing;
        }

        // Convert endpoints
        capabilities.endpoints = this.convertEndpointsToLatestSpec(capabilities.endpoints, version, updateEndpointPaths);

        // Fill STAC Version field
        if (!updateVersionNumbers && Versions.compare(version, "0.4.x", "=")) {
            capabilities.stac_version = "0.6.2";
        }
        else if (updateVersionNumbers || typeof capabilities.stac_version !== 'string') {
            capabilities.stac_version = "0.9.0";
        }

        // Add missing fields with somewhat useful data
        if (typeof capabilities.production !== 'boolean') {
            capabilities.production = Versions.compare(version, "1.0.0-rc.1", "=") || Versions.compare(version, "1.0.0-rc.2", "=") ? true : false;
        }
        if (typeof capabilities.backend_version !== 'string') {
            capabilities.backend_version = backend_version;
        }
        if (typeof capabilities.id !== 'string') {
            capabilities.id = id;
        }
        if (typeof capabilities.title !== 'string') {
            capabilities.title = title;
        }
        if (typeof capabilities.description !== 'string') {
            capabilities.description = "";
        }
        capabilities.links = MigrateCommons.migrateLinks(capabilities.links, version);

        return capabilities;
    }

    /**
     * Converts the billing part of the `GET /` response to the latest version.
     * 
     * Always returns a deep copy of the input object.
     * 
     * @param {object} billing - The response to convert
     * @param {string} version - Version number of the API, which the response conforms to
     * @returns {object}
     */
    static convertBillingToLatestSpec(billing, version) {
        if (Versions.compare(version, "0.3.x", "<=")) {
            throw "Migrating from API version 0.3.0 and older is not supported.";
        }
        if (Utils.isObject(billing)) {
            billing = Utils.deepClone(billing);
        }
        else {
            billing = {};
        }

        if (typeof billing.currency !== 'string') {
            billing.currency = null;
        }

        return billing;
    }

    /**
     * Converts the endpoints part of the `GET /` response to the latest version.
     * 
     * Always returns a deep copy of the input object.
     * 
     * @param {array} endpoints - The response to convert
     * @param {string} version - Version number of the API, which the response conforms to
     * @param {boolean} updatePaths - Should the endpoint paths be updated to their recent equivalents?
     * @returns {array}
     */
    static convertEndpointsToLatestSpec(endpoints, version, updatePaths = false) {
        if (Versions.compare(version, "0.3.x", "<=")) {
            throw "Migrating from API version 0.3.0 and older is not supported.";
        }
        if (!Array.isArray(endpoints)) {
            return [];
        }
        endpoints = Utils.deepClone(endpoints);
        // convert v0.4 endpoints to v1.0
        if (updatePaths) {
            let isV04 = Versions.compare(version, "0.4.x", "=");
            let isLtV100RC2 = Versions.compare(version, "1.0.0-rc.2", "<");

            let addPutToPg = function(endpoints) {
                let newPgPath = '/process_graphs/{process_graph_id}';
                let i = endpoints.findIndex(e => e.path === newPgPath);
                if (i >= 0) {
                    if (endpoints[i].methods.indexOf('PUT') === -1) {
                        endpoints[i].methods.push('PUT');
                    }
                }
                else {
                    endpoints.push({
                        path: newPgPath,
                        methods: ['PUT']
                    });
                }
                return endpoints;
            };

            for(var i in endpoints) {
                let e = endpoints[i];
                if (isV04) {
                    switch (e.path) {
                        case '/output_formats':
                            e.path = '/file_formats';
                            break;
                        case '/files/{user_id}':
                            e.path = '/files';
                            break;
                        case '/files/{user_id}/{path}':
                            e.path = '/files/{path}';
                            break;
                    }
                }
                if (isLtV100RC2) {
                    switch (e.path) {
                        case '/process_graphs':
                            let post = e.methods.indexOf('POST');
                            if (post >= 0) {
                                e.methods.splice(post, 1);
                                addPutToPg(endpoints);
                            }
                            break;
                        case '/process_graphs/{process_graph_id}':
                            let patch = e.methods.indexOf('PATCH');
                            if (patch >= 0) {
                                e.methods.splice(patch, 1);
                                addPutToPg(endpoints);
                            }
                            break;
                    }
                }
            }
        }
        return endpoints;
    }

    /**
     * Alias for `convertFileFormatsToLatestSpec()`.
     * 
     * @alias MigrateCapabilities.convertFileFormatsToLatestSpec
     * @deprecated
     * @param {object} formats - The response to convert
     * @param {string} version - Version number of the API, which the response conforms to
     * @returns {object}
     */
    static convertOutputFormatsToLatestSpec(formats, version) {
        return this.convertFileFormatsToLatestSpec(formats, version);
    }

    /**
     * Converts a `GET /file_formats` response to the latest version.
     * 
     * Always returns a deep copy of the input object.
     * 
     * @param {object} formats - The response to convert
     * @param {string} version - Version number of the API, which the response conforms to
     * @returns {object}
     */
    static convertFileFormatsToLatestSpec(formats, version) {
        if (Versions.compare(version, "0.3.x", "<=")) {
            throw "Migrating from API version 0.3.0 and older is not supported.";
        }
        if (Utils.isObject(formats)) {
            formats = Utils.deepClone(formats);
        }
        else {
            formats = {};
        }

        if (Versions.compare(version, "0.4.x", "=") && Utils.isObject(formats)) {
            formats = {
                output: formats
            };
        }

        formats.input = upgradeFileFormats(formats.input, version);
        formats.output = upgradeFileFormats(formats.output, version);

        return formats;
    }

    /**
     * Converts a `GET /service_types` response to the latest version.
     * 
     * Always returns a deep copy of the input object.
     * 
     * @param {object} types - The response to convert
     * @param {string} version - Version number of the API, which the response conforms to
     * @returns {object}
     */
    static convertServiceTypesToLatestSpec(types, version) {
        if (Versions.compare(version, "0.3.x", "<=")) {
            throw "Migrating from API version 0.3.0 and older is not supported.";
        }
        if (!Utils.isObject(types)) {
            return {};
        }

        types = Utils.deepClone(types);
        for(let t in types) {
            if (!Utils.isObject(types[t])) {
                types[t] = {};
            }
            if (Versions.compare(version, "0.4.x", "=")) {
                // Remove attributes
                delete types[t].attributes;

                // Rename parameters to configuration
                if (Utils.isObject(types[t].parameters)) {
                    types[t].configuration = types[t].parameters;
                }
                delete types[t].parameters;

                // Rename variables to process_parameters
                if (Array.isArray(types[t].variables)) {
                    types[t].process_parameters = types[t].variables.map(v => {
                        let param = {
                            name: v.variable_id,
                            description: typeof v.description === 'string' ? v.description : "",
                            schema: {
                                type: [
                                    typeof v.type === 'string' ? v.type : "string",
                                    "null"
                                ]
                            }
                        };
                        if (typeof v.default !== 'undefined') {
                            param.default = v.default;
                        }
                        return param;
                    });
                }
                delete types[t].variables;
            }

            if (!Utils.isObject(types[t].configuration)) {
                types[t].configuration = {};
            }
            else {
                types[t].configuration = MigrateCommons.migrateDiscoveryParameters(types[t].configuration, version);
            }

            if (!Array.isArray(types[t].process_parameters)) {
                types[t].process_parameters = [];
            }

            if (typeof types[t].links !== 'undefined') { // links not required, so only apply if defined anyway
                types[t].links = MigrateCommons.migrateLinks(types[t].links, version);
            }
        }
        return types;
    }

    /**
     * Converts a `GET /udf_runtimes` response to the latest version.
     * 
     * Always returns a deep copy of the input object.
     * 
     * @param {object} runtimes - The response to convert
     * @param {string} version - Version number of the API, which the response conforms to
     * @returns {object}
     */
    static convertUdfRuntimesToLatestSpec(runtimes, version) {
        if (Versions.compare(version, "0.3.x", "<=")) {
            throw "Migrating from API version 0.3.0 and older is not supported.";
        }
        if (!Utils.isObject(runtimes)) {
            return {};
        }

        runtimes = Utils.deepClone(runtimes);
        for(let r in runtimes) {
        // Nothing to do, was not supported in 0.3 and nothing changed in 0.4.
            if (Versions.compare(version, "0.4.x", "=")) {
                if (!Utils.isObject(runtimes[r])) {
                    delete runtimes[r];
                    continue;
                }

                // null is not allowed any longer, replace with empty string
                if (runtimes[r].description === null) {
                    runtimes[r].description = "";
                }
            }

            if (typeof runtimes[r].type !== 'string') {
                if (typeof runtimes[r].docker === 'string') {
                    runtimes[r].type = 'docker';
                }
                else {
                    runtimes[r].type = 'language';
                }
            }

            if (typeof runtimes[r].links !== 'undefined') { // links not required, so only apply if defined anyway
                runtimes[r].links = MigrateCommons.migrateLinks(runtimes[r].links, version);
            }
        }

        return runtimes;
    }

}

const GIS_DATA_TYPES = ['raster', 'vector', 'table', 'other'];

function upgradeFileFormats(formats, version) {
    if (!Utils.isObject(formats)) {
        formats = {};
    }
    for(let id in formats) {
        if (!Utils.isObject(formats[id].parameters)) {
            formats[id].parameters = {};
        }
        else {
            formats[id].parameters = MigrateCommons.migrateDiscoveryParameters(formats[id].parameters, version);
        }

        // Can be empty: https://github.com/Open-EO/openeo-api/issues/325
        if (!Array.isArray(formats[id].gis_data_types)) {
            formats[id].gis_data_types = [];
        }
        else {
            formats[id].gis_data_types = formats[id].gis_data_types.filter(t => GIS_DATA_TYPES.includes(t));
        }

        if (typeof formats[id].links !== 'undefined') { // links not required, so only apply if defined anyway
            formats[id].links = MigrateCommons.migrateLinks(formats[id].links, version);
        }
    }
    return formats;
}

module.exports = MigrateCapabilities;

/***/ }),

/***/ 899:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Utils = __webpack_require__(413);
const Versions = __webpack_require__(855);
const MigrateCommons = __webpack_require__(332);

const extMap = {
    "cube": "datacube",
    "eo": "eo",
    "label": "label",
    "pc": "pointcloud",
    "proj": "projection",
    "sar": "sar",
    "sat": "sat",
    "sci": "scientific",
    "view": "view"
};

const fieldMap = {
    // Item to core
    'item:license': 'license',
    'item:providers': 'providers',
    // EO to core
    'eo:instrument': 'instruments',
    'eo:platform': 'platform',
    'eo:constellation': 'constellation',
    // EO to proj
    'eo:epsg': 'proj:epsg',
    // EO to view
    'eo:off_nadir': 'view:off_nadir',
    'eo:azimuth': 'view:azimuth',
    'eo:sun_azimuth': 'view:sun_azimuth',
    'eo:sun_elevation': 'view:sun_elevation',
    // Datetime Range to core
    'dtr:start_datetime': 'start_datetime',
    'dtr:end_datetime': 'end_datetime',
    // Point Cloud
    'pc:schema': 'pc:schemas',
    // SAR rename
    'sar:type': 'sar:product_type',
    'sar:polarization': 'sar:polarizations',
    // SAR to core
    'sar:instrument': 'instruments',
    'sar:platform': 'platform',
    'sar:constellation': 'constellation',
    // SAR to sat
    'sar:off_nadir': 'sat:off_nadir_angle',
    'sar:relative_orbit': 'sat:relative_orbit',
// The following four fields don't translate directly, see code below
    'sar:pass_direction': 'sat:orbit_state',
//   sar:resolution => sar:resolution_range, sar:resolution_azimuth
//   sar:pixel_spacing => sar:pixel_spacing_range, sar:pixel_spacing_azimuth
//   sar:looks => sar:looks_range, sar:looks_azimuth, sar:looks_equivalent_number (opt)
};

const moveToRoot = [
    'cube:dimensions',
    'sci:publications',
    'sci:doi',
    'sci:citation'
];

const DIMENSION_TYPES = [
    'spatial',
    'temporal',
    'bands',
    'other'
];


/** Migrate Collections related responses to the latest version. */
class MigrateCollections {

    /**
     * Converts a `GET /collections` response to the latest version.
     * 
     * Always returns a deep copy of the input object.
     * 
     * @param {object} response - The response to convert
     * @param {string} version - Version number of the API, which the response conforms to
     * @returns {object}
     */
    static convertCollectionsToLatestSpec(response, version) {
        if (Versions.compare(version, "0.3.x", "<=")) {
            throw "Migrating from API version 0.3.0 and older is not supported.";
        }

        // Make sure we don't alter the original object
        response = Utils.deepClone(response);

        if (Array.isArray(response.collections)) {
            response.collections = response.collections
                .map(c => MigrateCollections.convertCollectionToLatestSpec(c, version))
                .filter(c => typeof c.id === 'string');
        }
        else {
            response.collections = [];
        }

        response.links = MigrateCommons.migrateLinks(response.links, version);

        return response;
    }

    /**
     * Converts a single collection to the latest version.
     * 
     * Always returns a deep copy of the input object.
     * 
     * @param {object} process - The collection to convert
     * @param {string} version - Version number of the API, which the collection conforms to
     * @returns {object}
     */
    static convertCollectionToLatestSpec(originalCollection, version) {
        if (Versions.compare(version, "0.3.x", "<=")) {
            throw "Migrating from API version 0.3.0 and older is not supported.";
        }

        // Make sure we don't alter the original object
        let collection = Utils.deepClone(originalCollection);

        // If collection has no id => seems to be an invalid collection => abort
        if (typeof collection.id !== 'string' || collection.id.length === 0) {
            return {};
        }

        // Update stac_version
        if (!Versions.validate(collection.stac_version) || Versions.compare(collection.stac_version, "0.9.0", "<")) {
            collection.stac_version = "0.9.0";
        }

        // Add missing extent upfront. Makes the following code simpler as it works on the object.
        if (!Utils.isObject(collection.extent)) {
            collection.extent = {};
        }

        // convert v0.4 collections to latest version
        if (Versions.compare(version, "0.4.x", "=")) {
            // Restructure spatial extent
            if (Array.isArray(collection.extent.spatial)) {
                collection.extent.spatial = {
                    bbox: [
                        collection.extent.spatial
                    ]
                };
            }
            // Restructure temporal extent
            if (Array.isArray(collection.extent.temporal)) {
                collection.extent.temporal = {
                    interval: [
                        collection.extent.temporal
                    ]
                };
            }

            // move properties to other_properties
            if (Utils.isObject(collection.properties)) {
                if (!Utils.isObject(collection.other_properties)) {
                    collection.other_properties = {};
                }
                for(let key in collection.properties) {
                    collection.other_properties[key] = {
                        values: [
                            collection.properties[key]
                        ]
                    };
                }
            }
            delete collection.properties;

            // now we can work on all properties and migrate to summaries
            let props = Utils.isObject(collection.other_properties) ? collection.other_properties : {};
            for(let key in props) {
                let val = props[key];
                if (Utils.isObject(val) && (Array.isArray(val.extent) || Array.isArray(val.values))) {
                    if (Array.isArray(val.extent)) {
                        props[key] = {
                            min: val.extent[0],
                            max: val.extent[1]
                        };
                    }
                    else { // val.values is an array
                        if (val.values.findIndex(v => !Array.isArray(v)) === -1) {
                            if (val.values.length <= 1) {
                                props[key] = val.values[0];
                            }
                            else {
                                props[key] = val.values.reduce((a, b) => a.concat(b));
                            }
                        }
                        else {
                            props[key] = val.values;
                        }
                    }
                }
                else {
                    // If not valid, move to top-level
                    if (typeof collection[key] === 'undefined') {
                        collection[key] = val;
                    }
                    delete props[key];
                }
            }
            delete collection.other_properties;

            if (!Utils.isObject(collection.summaries)) {
                collection.summaries = {};
            }
            for(let key in props) {
                let val = props[key];

                if (key === 'sar:pass_direction') {
                    // Convert null to geostationary
                    val = val.map(v => v === null ? 'geostationary' : v);
                }

                // Convert arrays into separate fields as needed for some SAR fields
                if ((key === 'sar:resolution' || key === 'sar:pixel_spacing' || key === 'sar:looks') && Array.isArray(val) && val.length >= 2) {
                    collection.summaries[key + '_range'] = val.slice(0,1);
                    collection.summaries[key + '_azimuth'] = val.slice(1,2);
                    if (val.length > 2) {
                        collection.summaries[key + '_equivalent_number'] = val.slice(2,3);
                    }
                }
                // Do the renaming of fields
                else if (typeof fieldMap[key] === 'string') {
                    collection.summaries[fieldMap[key]] = val;
                }
                // Move invalid summaries to the top level
                else if (moveToRoot.includes(key) && Array.isArray(val) && val.length === 1) {
                    collection[key] = val[0];
                }
                // Do the general conversion
                else {
                    collection.summaries[key] = val;
                }
            }
        }

        // Add missing required fields
        if (typeof collection.description !== 'string') {
            collection.description = "";
        }
        if (!Utils.isObject(collection.extent.spatial)) {
            collection.extent.spatial = {};
        }
        if (!Utils.isObject(collection.extent.temporal)) {
            collection.extent.temporal = {};
        }
        if (typeof collection.license !== 'string') {
            collection.license = "proprietary";
        }
        if (!Utils.isObject(collection.summaries)) {
            collection.summaries = {};
        }
        if (!Utils.isObject(collection['cube:dimensions'])) {
            collection['cube:dimensions'] = {};
        }
        else {
            for(var name in collection['cube:dimensions']) {
                if (Utils.isObject(collection['cube:dimensions'][name]) && !DIMENSION_TYPES.includes(collection['cube:dimensions'][name].type)) {
                    collection['cube:dimensions'][name].type = 'other';
                }
            }
        }

        // Fix links
        collection.links = MigrateCommons.migrateLinks(collection.links);

        // Fix stac_extensions
        var extensions = Array.isArray(collection.stac_extensions) ? collection.stac_extensions : [];
        for(var key in collection) {
            let ext = null;
            let prefix = key.split(':', 1);
            if (key === 'deprecated' || key === 'version') {
                ext = 'version';
            }
            else if (typeof extMap[prefix] === 'string') {
                ext = extMap[prefix];
            }

            if (ext !== null && !extensions.includes(ext)) {
                extensions.push(ext);
            }
        }
        extensions.sort();
        collection.stac_extensions = extensions;

        return collection;
    }

}

module.exports = MigrateCollections;

/***/ }),

/***/ 332:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Utils = __webpack_require__(413);
const Versions = __webpack_require__(855);

class MigrateCommons {

	static migrateLinks(links, version, fallbackRel = 'related') {
		if (!Array.isArray(links)) {
			return [];
		}

		return links
			.filter(link => Utils.isObject(link) && typeof link.href === 'string')
			.map(link => {
				if (typeof link.rel !== 'string') {
					link.rel = fallbackRel;
				}
				return link;
			});
	}

	static migrateDiscoveryParameters(parameters, version) {
		if (Versions.compare(version, "1.0.0-rc.2", "<=")) {
			for(var name in parameters) {
				if (!Utils.isObject(parameters[name])) {
					delete parameters[name];
					continue;
				}

				let type = parameters[name].type;
				if (typeof type === 'string') {
					parameters[name].type = [type, "null"];
				}

				let example = parameters[name].example;
				if (typeof example !== 'undefined') {
					parameters[name].examples = [example];
					delete parameters[name].example;
				}
			}
		}

		return parameters;
	}

}

module.exports = MigrateCommons;

/***/ }),

/***/ 327:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Utils = __webpack_require__(413);
const Versions = __webpack_require__(855);
const MigrateCommons = __webpack_require__(332);

/** Migrate processes related responses to the latest version. */
class MigrateProcesses {

    /**
     * Converts a `GET /process` response to the latest version.
     * 
     * Always returns a deep copy of the input object.
     * 
     * @param {object} response - The response to convert
     * @param {string} version - Version number of the API, which the response conforms to
     * @returns {object}
     */
    static convertProcessesToLatestSpec(response, version) {
        if (Versions.compare(version, "0.3.x", "<=")) {
            throw "Migrating from API version 0.3.0 and older is not supported.";
        }

        // Make sure we don't alter the original object
        response = Utils.deepClone(response);

        if (Array.isArray(response.processes)) {
            response.processes = response.processes
                .map(p => MigrateProcesses.convertProcessToLatestSpec(p, version))
                .filter(p => typeof p.id === 'string');
        }
        else {
            response.processes = [];
        }

        response.links = MigrateCommons.migrateLinks(response.links, version);

        return response;
    }

    /**
     * Converts a single process to the latest version.
     * 
     * Always returns a deep copy of the input object.
     * 
     * @param {object} process - The process to convert
     * @param {string} version - Version number of the API, which the process conforms to
     * @returns {object}
     */
    static convertProcessToLatestSpec(process, version) {
        if (Versions.compare(version, "0.3.x", "<=")) {
            throw "Migrating from API version 0.3.0 and older is not supported.";
        }

        // Make sure we don't alter the original object
        process = Utils.deepClone(process);

        // If process has no id => seems to be an invalid process => abort
        if (typeof process.id !== 'string' || process.id.length === 0) {
            return {};
        }

        // Convert the parameters from object to array
        if (Versions.compare(version, "0.4.x", "=")) {
            // Determine the parameter order
            if (!Array.isArray(process.parameter_order) || process.parameter_order.length === 0) {
                process.parameter_order = [];
                for(let param in process.parameters) {
                    process.parameter_order.push(param);
                }
            }
    
            // Upgrade parameters and convert from array to object
            let params = [];
            for(let name of process.parameter_order) {
                // Add name 
                let obj = {name: name};
                if (Utils.isObject(process.parameters[name])) {
                    Object.assign(obj, process.parameters[name]);
                }

                // Migrate from required to optional
                if (!obj.required) {
                    obj.optional = true;
                }
                delete obj.required;

                // Add to list of ordered params
                params.push(obj);
            }
            delete process.parameter_order;
            process.parameters = params;
        }

        // Set required field description if not a string
        if (typeof process.description !== 'string') {
            process.description = "";
        }

        // Update parameters
        if (Array.isArray(process.parameters)) {
            for (var i = process.parameters.length-1; i >= 0; i--) {
                let param = process.parameters[i];
                if (!Utils.isObject(param)) {
                    process.parameters.splice(i, 1);
                    continue;
                }

                // Set required field description if not a string
                if (typeof param.description !== 'string') {
                    param.description = "";
                }

                // Upgrade parameter schema
                process.parameters[i] = upgradeSchema(param, version);
            }
        }
        else {
            process.parameters = [];
        }

        // Update return value
        if (!Utils.isObject(process.returns)) {
            process.returns = {};
        }
        process.returns = upgradeSchema(process.returns, version, false);

        // Remove process graphs from examples (and ensure there are arguments given)
        if (Array.isArray(process.examples)) {
            process.examples = process.examples.filter(example => Utils.isObject(example) && Utils.isObject(example.arguments));
        }

        if (typeof process.links !== 'undefined') { // links not required, so only apply if defined anyway
            process.links = MigrateCommons.migrateLinks(process.links, version);
        }

        // Update process graph -> nothing to do yet

        return process;
    }

}
    
function upgradeSchema(obj, version, isParam = true) {
    var schema = {};
    if (obj.schema && typeof obj.schema === 'object') { // array or object?
        schema = obj.schema;
    }

    if (Versions.compare(version, "0.4.x", "=")) {
        // Remove anyOf/oneOf wrapper
        for(let type of ['anyOf', 'oneOf']) {
            if (Array.isArray(schema[type])) {
                // Parameters only: Move default value to parameter-level
                if (isParam && typeof schema.default !== 'undefined') {
                    obj.default = schema.default;
                }
                // Move array one level up, removing anyOf and oneOf
                schema = schema[type];
                break;
            }
        }

        let moveMediaType = (Versions.compare(version, "0.4.x") <= 0 && typeof obj.media_type !== 'undefined');
        let schemas = Array.isArray(schema) ? schema : [schema];
        for(let subSchema of schemas) {
            // Rename format to subtype recursively
            subSchema = renameFormat(subSchema);

            // Parameters only: Move default value to parameter-level
            if (isParam && typeof subSchema.default !== 'undefined') {
                obj.default = subSchema.default;
                delete subSchema.default;
            }

            // Replace media_type field with contentMediaType from JSON Schemas
            if (moveMediaType) {
                subSchema.contentMediaType = obj.media_type;
            }
        }

        // Remove the media type
        if (moveMediaType) {
            delete obj.media_type;
        }
    }

    // Clients SHOULD automatically set `optional` to `true`, if a default value is specified.
    if (Versions.compare(version, "0.4.x", ">")) {
        if (typeof obj.default !== 'undefined') {
            obj.optional = true;
        }
    }

    obj.schema = schema;
    return obj;
}

function renameFormat(schema) {
    if (Utils.isObject(schema) && typeof schema.type !== 'undefined' && typeof schema.format === 'string') {
        switch(schema.format) {
            case 'url':
                schema.format = 'uri';
                break;
            case 'proj-definition':
                schema.deprecated = true;
                break;
            case 'callback':
                schema.format = 'process-graph';
                if (Utils.isObject(schema.parameters)) {
                    let params = [];
                    for(let name in schema.parameters) {
                        let paramSchema = schema.parameters[name];
                        let param = {
                            name: name,
                            description: typeof paramSchema.description === 'string' ? paramSchema.description : "",
                            schema: paramSchema
                        };
                        params.push(param);
                    }
                    schema.parameters = params;
                }
                break;
        }

        schema.subtype = schema.format;
        // Leave format for "well-known" formats defined in JSON Schema
        if (!['date-time', 'time', 'date', 'uri'].includes(schema.format)) {
            delete schema.format;
        }
    }
    for(let i in schema) {
        if (schema[i] && typeof schema[i] === 'object') {
            schema[i] = renameFormat(schema[i]);
        }
    }
    return schema;
}

module.exports = MigrateProcesses;

/***/ }),

/***/ 809:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Utils = __webpack_require__(413);

/**
 * Wrapper class for a single data type definition in a schema (e.g. process parameter schema, return value schema).
 * 
 * @class
 */
class ProcessDataType {
	
	/**
	 * Constructs a new process data type based on JSON Schema.
	 * 
	 * @param {object} schema
	 * @param {?ProcessSchema} [parent=null]
	 * @param {*} [defaultValue=undefined]
	 */
	constructor(schema, parent = null, defaultValue = undefined) {
		this.schema = schema;
		if (typeof this.schema.default === 'undefined') {
			this.schema.default = defaultValue;
		}
		this.parent = parent;
	}

	/**
	 * Converts the schema to a JSON-serializable representation.
	 * 
	 * @returns {object}
	 */
	toJSON() {
		return Object.assign({}, this.schema, {default: this.default()});
	}

	/**
	 * Checks whether the data type is only `null`.
	 * 
	 * @returns {boolean}
	 */
	isAny() {
		return this.dataType() === 'any';
	}

	/**
	 * Checks whether the data type is only `null`.
	 * 
	 * @returns {boolean}
	 */
	isNull() {
		return this.schema.type === 'null';
	}

	/**
	 * Checks whether the data type allows `null`.
	 * 
	 * @returns {boolean}
	 */
	nullable() {
		return this.isNull() || this.isAny();
	}

	/**
	 * Returns whether the data type is editable.
	 * 
	 * This means it returns `true`, unless certain data types are detected that
	 * can't be transmitted via JSON in the openEO API (e.g. data cubes or labeled arrays).
	 * 
	 * @returns {boolean}
	 */
	isEditable() {
		return !ProcessDataType.NON_EDITABLE.includes(this.dataType());
	}

	/**
	 * Returns the data type.
	 * 
	 * The priority is as such:
	 * - subtype
	 * - native data type
	 * - "any"
	 * 
	 * @param {boolean} [native=false] - Set to true to only return the native data type.
	 * @returns {string}
	 */
	dataType(native = false) {
		let nativeType = this.schema.type || "any";
		return native ? nativeType : (this.schema.subtype || nativeType);
	}

	/**
	 * Returns the native data type of the schema.
	 * 
	 * One of: array, object, null, string, boolean, number or any
	 * 
	 * @returns {string}
	 */
	nativeDataType() {
		return this.dataType(true);
	}

	/**
	 * Checks whether the data type contains an enumeration of values.
	 * 
	 * @returns {boolean}
	 * @see ProcessDataType#getEnumChoices
	 */
	isEnum() {
		return Array.isArray(this.schema.enum) && this.schema.enum.length > 0;
	}

	/**
	 * Returns the allowed enumeration of values.
	 * 
	 * @returns {array}
	 * @see ProcessDataType#isEnum
	 */
	getEnumChoices() {
		return this.isEnum() ? this.schema.enum : [];
	}

	/**
	 * Returns the parameters for a "child process" that is defined for the data type.
	 * 
	 * @returns {array<object>}
	 */
	getCallbackParameters() {
		if (Array.isArray(this.schema.parameters)) { // For "normal" callbacks
			return this.schema.parameters;
		}
		else if (Utils.isObject(this.schema.additionalProperties) && Array.isArray(this.schema.additionalProperties.parameters)) {
			return this.schema.additionalProperties.parameters; // Used for metadata-filter
		}
		else {
			return [];
		}
	}

	/**
	 * Returns the group of the data type.
	 * 
	 * Group is a "extension" of JSON Schema, which allows to group schemas by certain criteria.
	 * 
	 * @returns {string}
	 */
	group() {
		return Utils.hasText(this.schema.group) ? this.schema.group : ProcessDataType.DEFAULT_GROUP;
	}

	/**
	 * Returns the title of the data type.
	 * 
	 * If no title is present, returns a "prettified" version of the data type
	 * (e.g. "Temporal Interval" for the data type "temporal-interval").
	 * 
	 * @returns {string}
	 */
	title() {
		if (Utils.hasText(this.schema.title)) {
			return this.schema.title;
		}
		else {
			return Utils.prettifyString(this.dataType());
		}
	}

	/**
	 * Returns the description of the data type.
	 * 
	 * @returns {string}
	 */
	description() {
		return Utils.hasText(this.schema.description) ? this.schema.description : "";
	}

	/**
	 * Returns the default value of the data type.
	 * 
	 * This may return `undefined`.
	 * 
	 * @returns {*}
	 */
	default() {
		if (typeof this.schema.default === 'function') {
			return this.schema.default();
		}
		return this.schema.default;
	}

}

/**
 * The name of the default group for schemas.
 * 
 * Defaults to `Other`.
 * 
 * @type {string}
 */
ProcessDataType.DEFAULT_GROUP = 'Other';
/**
 * A list of data types that can't be edited.
 * 
 * Non-editable data types can't be transmitted via JSON through the openEO API
 * (e.g. data cubes or labeled arrays).
 * 
 * @type {array<string>}
 */
ProcessDataType.NON_EDITABLE = [
	'raster-cube',
	'vector-cube',
	'labeled-array',
	'datacube'
];

module.exports = ProcessDataType;

/***/ }),

/***/ 578:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ProcessSchema = __webpack_require__(570);

/**
 * Wrapper class for a process parameter.
 * 
 * @class
 */
class ProcessParameter extends ProcessSchema {

	/**
	 * Constructs a new process parameter based on the openEO API representation.
	 * 
	 * @param {object} parameter 
	 */
	constructor(parameter) {
		super(parameter.schema, parameter.default);

		Object.assign(this, parameter);
	}

}

module.exports = ProcessParameter;

/***/ }),

/***/ 502:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Utils = __webpack_require__(413);

/**
 * Central registry for processes.
 * 
 * @class
 */
class ProcessRegistry {

	/**
	 * Creates a new registry of all processes.
	 * 
	 * @param {Array.<object>|ProcessRegistry} [processes=[]] - Optionally, a list of predefined processes.
	 * @param {boolean} [addNamespace=false] - Add a namespace property to processes if set to `true`.
	 */
	constructor(processes = [], addNamespace = false) {
		/**
		 * List of listeners for change events.
		 * @public
		 */
		this.listeners = [];
		/**
		 * Object of namespaces and processes.
		 * @protected
		 * @type {object.<string,object.<string,object>>}
		 */
		this.processes = {};
		/**
		 * Add a namespace property to processes if set to `true`.
		 * @protected
		 * @type {boolean}
		 */
		this.addNamespace = addNamespace;

		// Fill process list
		if (processes instanceof ProcessRegistry) {
			for(let namespace in processes.processes) {
				this.addAll(processes.processes[namespace]);
			}
		}
		else {
			this.addAll(processes);
		}
	}

	/**
	 * Event that is fired on changes, notifies listeners.
	 * 
	 * @param {string} event - One of 'add', 'addAll' or 'remove'.
	 * @param {*} data 
	 * @param {string} namespace 
	 */
	onChange(event, data, namespace) {
		for(let listener of this.listeners) {
			listener(event, data, namespace);
		}
	}

	/**
	 * Adds a list of processes for a given namespace.
	 * 
	 * Replaces an existing process in the given namespace if it exists.
	 * 
	 * Fires 'addAll' event.
	 * 
	 * @param {Array.<object>} processes Optionally, a list of processes
	 * @param {string} [namespace="backend"] The namespace for the processes (defaults to 'backend', i.e. pre-defined processes)
	 */
	addAll(processes, namespace = 'backend') {
		for(var i in processes) {
			this.add(processes[i], namespace, false);
		}
		this.onChange('addAll', processes, namespace);
	}

	/**
	 * Adds a single process to a given namespace.
	 * 
	 * Replaces an existing process in the given namespace if it exists.
	 * 
	 * Fires 'add' event.
	 * 
	 * @param {object} processes A process definition
	 * @param {string} [namespace="backend"] The namespace for the process (defaults to 'backend', i.e. pre-defined processes)
	 */
	add(process, namespace = 'backend', fireEvent = true) {
		if (!Utils.isObject(process)) {
			throw new Error("Invalid process; not an object.");
		}
		if (typeof process.id !== 'string') {
			throw new Error("Invalid process; no id specified.");
		}
		if (typeof namespace !== 'string') {
			throw new Error("Invalid namespace; not a string.");
		}

		if (!this.processes[namespace]) {
			this.processes[namespace] = {};
		}
		process = Object.assign(this.addNamespace ? {namespace} : {}, process);
		this.processes[namespace][process.id] = process;
		if (fireEvent) {
			this.onChange('add', process, namespace);
		}
	}

	/**
	 * Returns the count of all processes independant of the namespaces.
	 * 
	 * @returns {number} 
	 */
	count() {
		return Utils.size(this.all());
	}

	/**
	 * Returns all processes as a list, independant of the namespaces.
	 * 
	 * @returns {Array.<object>} 
	 */
	all() {
		let processes = [];
		for(let ns in this.processes) {
			processes = processes.concat(Object.values(this.processes[ns]));
		}
		return processes;
	}

	/**
	 * Checks whether a namespace exists (i.e. at least one process for the namespace exists)
	 * 
	 * @param {string} namespace The namespace
	 * @returns {boolean}
	 */
	hasNamespace(namespace) {
		if(typeof namespace !== 'string') {
			return false;
		}
		return Boolean(this.processes[namespace]);
	}

	/**
	 * Returns a (sorted) list of all available namespaces.
	 * 
	 * @returns {Array.<string>} 
	 */
	namespaces() {
		return Object.keys(this.processes).sort();
	}

	/**
	 * Returns all processes from a specific namespace.
	 * 
	 * Returns an empty list if the namespace is not defined.
	 * 
	 * @param {string} namespace The namespace of the processes to return (e.g. 'backend' for pre-defined processes)
	 * @returns {Array.<object>} 
	 */
	namespace(namespace) {
		if(typeof namespace !== 'string') {
			return [];
		}
		let processes = this.processes[namespace];
		return processes ? Object.values(processes) : [];
	}

	/**
	 * Checks whether a process with the given ID exists in the given namespace.
	 * 
	 * If the namespace is set to `null` (default) then it checks both user processes and backend processes.
	 * The default namespace for pre-defined processes is `backend`.
	 * 
	 * @param {string} id The process identifier
	 * @param {?string} [namespace=null] The namespace of the process
	 * @returns {boolean} 
	 */
	has(id, namespace = null) {
		return Boolean(this.get(id, namespace));
	}
	
	/**
	 * Retrieve the process with the given ID fron the given namespace.
	 * 
	 * If the namespace is set to `null` (default) then it retrieces from both (1) `user` processes and (2) `backend` processes
	 * with preference to user processes on conflict. The default namespace for pre-defined processes is `backend`.
	 * 
	 * @param {string} id The process identifier
	 * @param {?string} [namespace=null] The namespace of the process
	 * @returns {object} 
	 */
	get(id, namespace = null) {
		if (typeof id !== 'string') {
			return null;
		}

		// If no namespace is set, prefer the user namespace over backend namespace
		if (namespace === null) {
			return this.get(id, 'user') || this.get(id, 'backend');
		}

		if (this.processes[namespace]) {
			return this.processes[namespace][id] || null;
		}
		return null;
	}

	/**
	 * Removes a single process or a complete namespace from the registry.
	 * 
	 * If nothing is given, removes the namespace 'user'.
	 * If only a namespace is given, removes the whole namespace.
	 * If only a process is given, removes a process from the namespace `user`.
	 * If both parameters are given, removes a process from the given namespace.
	 * 
	 * Returns `true` on succes, `false` on failure.
	 * 
	 * Fires 'remove' event.
	 * 
	 * @param {?string} [id=null] The process identifier
	 * @param {?string} [namespace="user"] The namespace, defaults to `user`
	 * @returns {boolean}
	 */
	remove(id = null, namespace = 'user') {
		if (typeof namespace !== 'string') {
			return false;
		}

		if (this.processes[namespace]) {
			if (typeof id === 'string') {
				if (this.processes[namespace][id]) {
					let process = this.processes[namespace][id];
					delete this.processes[namespace][id];
					if (Utils.size(this.processes[namespace]) === 0) {
						delete this.processes[namespace];
					}
					this.onChange('remove', process, namespace);
					return true;
				}
			}
			else {
				delete this.processes[namespace];
				this.onChange('remove', null, namespace);
				return true;
			}
		}

		return false;
	}

}

module.exports = ProcessRegistry;

/***/ }),

/***/ 570:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ProcessUtils = __webpack_require__(464);
const ProcessDataType = __webpack_require__(809);
const Utils = __webpack_require__(413);

/**
 * Wrapper class for the process schemas (i.e. from parameters or return value).
 * 
 * @class
 */
class ProcessSchema {
	
	/**
	 * Constructs a new process schema based on the openEO API representation.
	 * 
	 * Can be array or JSON Schema object. The array consists of multiple JSON Schemas then.
	 * 
	 * @param {?object|array} [schema=null]
	 * @param {*} [defaultValue=undefined]
	 */
	constructor(schema = null, defaultValue = undefined) {
		if (!Utils.isObject(schema) && !Array.isArray(schema)) {
			this.unspecified = true;
			this.schemas = [];
		}
		else {
			this.unspecified = false;
			this.schemas = ProcessUtils.normalizeJsonSchema(schema, true).map(s => new ProcessDataType(s, this, defaultValue));

			// Find and assign the default value from sub-schemas if no defaultValue was given
			if (typeof defaultValue === 'undefined') {
				let defaults = this.schemas
					.map(s => s.default())
					.filter(d => typeof d !== 'undefined');
				this.default = defaults[0];
			}
			else {
				this.default = defaultValue;
			}
		}

		this.refs = [];
	}

	/**
	 * Converts the schemas to a JSON-serializable representation.
	 * 
	 * @returns {object}
	 */
	toJSON() {
		return this.schemas.map(s => s.toJSON());
	}

	/**
	 * Returns whether the schema is editable.
	 * 
	 * This means it returns `true`, unless certain data types are detected that
	 * can't be transmitted via JSON in the openEO API (e.g. data cubes or labeled arrays).
	 * 
	 * @returns {boolean}
	 */
	isEditable() {
		return (this.unspecified || this.schemas.filter(s => s.isEditable() && !s.isNull()).length > 0);
	}

	/**
	 * Checks whether the schema is exactly and only of the given data type.
	 * 
	 * Can be a native type or a openEO "subtype".
	 * 
	 * @param {string} type 
	 * @returns {boolean}
	 */
	is(type) {
		var types = this.dataTypes();
		return (types.length === 1 && types[0] === type);
	}

	/**
	 * Returns the native data type of the schema.
	 * 
	 * One of: array, object, null, string, boolean, number
	 * 
	 * @returns {string}
	 */
	nativeDataType() {
		return this.dataType(true);
	}

	/**
	 * Returns the data type of the associated schemas.
	 * 
	 * Setting `native` to `true` will only consider native JSON data types and "any".
	 * Otherwise, subtypes will also be considered.
	 * 
	 * If the schema has a two data types and one of them is `null`, 
	 * `null` is ignored and just the other data type is returned.
	 * 
	 * `nullable()` can be used to check whether a schema allows `null`.
	 * 
	 * Returns `mixed` if multiple data types are allowed.
	 * 
	 * @param {boolean} [native=false]
	 * @returns {string}
	 * @see ProcessSchema#nullable
	 */
	dataType(native = false) {
		var types = this.dataTypes(true, native);
		var nullIndex = types.indexOf('null');
		if (types.length === 1) {
			return types[0];
		}
		else if (types.length === 2 && nullIndex !== -1) {
			return types[nullIndex === 0 ? 1 : 0];
		}
		else {
			return 'mixed';
		}
	}

	/**
	 * Returns a set of all supported distinct data types (or 'any').
	 * 
	 * By default, `null` is not included in the list of data types.
	 * Setting `includeNull` to `true` to include `null` in the list.
	 * 
	 * Setting `native` to `true` will only consider native JSON data types and "any".
	 * Otherwise, subtypes will also be considered.
	 * 
	 * @param {boolean} [includeNull=false]
	 * @param {boolean} [native=false]
	 * @returns {array<string>}
	 */
	dataTypes(includeNull = false, native = false) {
		var types = this.schemas
			.map(s => s.dataType(native))
			.filter((v, i, a) => a.indexOf(v) === i); // Return each type only once
		if (types.length === 0 || types.includes('any')) {
			return ['any'];
		}
		return includeNull ? types : types.filter(s => s !== 'null');
	}

	/**
	 * Checks whether one of the schemas allows the value to be `null`.
	 * 
	 * @returns {boolean}
	 */
	nullable() {
		return (this.unspecified || this.schemas.filter(s => s.nullable()).length > 0);
	}

}

module.exports = ProcessSchema;

/***/ }),

/***/ 464:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Utils = __webpack_require__(413);

/**
 * Utilities to parse process specs and JSON schemas.
 * 
 * @class
 */
class ProcessUtils {

	/**
	 * From a "complex" JSON Schema with allOf/anyOf/oneOf, make separate schemas.
	 * 
	 * So afterwards each schema has it's own array entry.
	 * It merges allOf, resolves anyOf/oneOf into separate schemas.
	 * May also split the JSON Schema type arrays into separate entries by setting `splitTypes` to `true`.
	 * 
	 * @param {object|array} schemas - The JSON Schema(s) to convert
	 * @returns {array}
	 */
	static normalizeJsonSchema(schemas, splitTypes = false) {
		// Make schemas always an array
		if (Utils.isObject(schemas)) {
			schemas = [schemas];
		}
		else if (Array.isArray(schemas)) {
			schemas = schemas;
		}
		else {
			schemas = [];
		}

		// Merge allOf, resolve anyOf/oneOf into separate schemas
		let normalized = [];
		for(let schema of schemas) {
			if (Array.isArray(schema.allOf)) {
				normalized.push(Object.assign({}, ...schema.allOf));
			}
			else if (Array.isArray(schema.oneOf) || Array.isArray(schema.anyOf)) {
				let copy = Utils.omitFromObject(schema, ['oneOf', 'anyOf']);
				let subSchemas = schema.oneOf || schema.anyOf;
				for(let subSchema of subSchemas) {
					normalized.push(Object.assign({}, copy, subSchema));
				}
			}
			else {
				normalized.push(schema);
			}
		}

		if (!splitTypes) {
			return normalized;
		}

		// Split type field into separate schemas
		schemas = [];
		for(let schema of normalized) {
			if (Array.isArray(schema.type)) {
				/* jshint ignore:start */
				schemas = schemas.concat(schema.type.map(type => Object.assign({}, schema, {type: type})));
				/* jshint ignore:end */
			}
			else {
				schemas.push(schema);
			}
		}

		return schemas;
	}

	/**
	 * Returns the callback parameters for a given process parameter.
	 * 
	 * @param {object} processParameter - The process parameter spec to parse.
	 * @returns {array}
	 * @throws {Error}
	 */
	static getCallbackParameters(processParameter, keyPath = []) {
		if (!Utils.isObject(processParameter) || !processParameter.schema) {
			return [];
		}

		let schemas = ProcessUtils.normalizeJsonSchema(processParameter.schema);
		let key;
		while(key = keyPath.shift()) { // jshint ignore:line
			schemas = schemas.map(schema => ProcessUtils.normalizeJsonSchema(ProcessUtils.getElementJsonSchema(schema, key))); // jshint ignore:line
			schemas = schemas.concat(...schemas);
		}


		let cbParams = [];
		for(let schema of schemas) {
			let params = null;
			if (Array.isArray(schema.parameters)) { // For "normal" callbacks
				params = schema.parameters;
			}
			else if (Utils.isObject(schema.additionalProperties) && Array.isArray(schema.additionalProperties.parameters)) {
				params = schema.additionalProperties.parameters; // Used for metadata-filter
			}
			if (Array.isArray(params)) {
				if (cbParams.length > 0 && !Utils.equals(cbParams, params)) {
					throw new Error("Multiple schemas with different callback parameters found.");
				}
				cbParams = params;
			}
		}

		return cbParams;
	}

	/**
	 * Returns the callback parameters for a given process parameter from a full process spec.
	 * 
	 * @param {object} process - The process to parse.
	 * @param {string} parameterName - The name of the parameter to get the callback parameters for.
	 * @returns {array}
	 * @throws {Error}
	 */
	static getCallbackParametersForProcess(process, parameterName, path = []) {
		if (!Utils.isObject(process) || !Array.isArray(process.parameters)) {
			return [];
		}

		let param = process.parameters.find(p => p.name === parameterName);
		return ProcessUtils.getCallbackParameters(param, path);
	}

	/**
	 * Returns *all* the native JSON data types allowed for the schema.
	 * 
	 * @param {object} schema 
	 * @param {boolean} anyIsEmpty
	 * @returns {array}
	 */
	static getNativeTypesForJsonSchema(schema, anyIsEmpty = false) {
		if (Utils.isObject(schema) && Array.isArray(schema.type)) {
			// Remove duplicate and invalid types
			let validTypes = Utils.unique(schema.type).filter(type => ProcessUtils.JSON_SCHEMA_TYPES.includes(type));
			if (validTypes.length > 0 && validTypes.length < ProcessUtils.JSON_SCHEMA_TYPES.length) {
				return validTypes;
			}
			else {
				return anyIsEmpty ? [] : ProcessUtils.JSON_SCHEMA_TYPES;
			}
		}
		else if (Utils.isObject(schema) && typeof schema.type === 'string' && ProcessUtils.JSON_SCHEMA_TYPES.includes(schema.type)) {
			return [schema.type];
		}
		else {
			return anyIsEmpty ? [] : ProcessUtils.JSON_SCHEMA_TYPES;
		}
	}

	/**
	 * Returns the schema for a property of an object or an element of an array.
	 * 
	 * If you want to retrieve the schema for a specific key, use the parameter `key`.
	 * 
	 * @param {object} schema - The JSON schema to parse.
	 * @param {string|integer|null} key - If you want to retrieve the schema for a specific key, otherwise null.
	 * @returns {object} - JSON Schema
	 */
	static getElementJsonSchema(schema, key = null) {
		let types = ProcessUtils.getNativeTypesForJsonSchema(schema);
		if (Utils.isObject(schema) && types.includes('array') && typeof key !== 'string') {
			if (Utils.isObject(schema.items)) {
				// Array with one schema for all items: https://json-schema.org/understanding-json-schema/reference/array.html#id5
				return schema.items;
			}
			else if (Array.isArray(schema.items)) {
				// Tuple validation: https://json-schema.org/understanding-json-schema/reference/array.html#id6
				if (key !== null && Utils.isObject(schema.items[key])) {
					return schema.items[key];
				}
				else if (Utils.isObject(schema.additionalItems)) {
					return schema.additionalItems;
				}
			}
		}
		if (Utils.isObject(schema) && types.includes('object')) {
			if (key !== null && Utils.isObject(schema.properties) && Utils.isObject(schema.properties[key])) {
				return schema.properties[key];
			}
			else if (Utils.isObject(schema.additionalProperties)) {
				return schema.additionalProperties;
			}
			// ToDo: No support for patternProperties yet
		}

		return {};
	}

}

/**
 * A list of all allowed JSON Schema type values.
 * 
 * @type {array}
 */
ProcessUtils.JSON_SCHEMA_TYPES = ['string', 'number', 'integer', 'boolean', 'array', 'object', 'null'];

module.exports = ProcessUtils;

/***/ }),

/***/ 413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var equal = __webpack_require__(252);

/**
 * General utilities
 * 
 * @class
 */
class Utils {

	/**
	 * Checks whether a variable is a real object or not.
	 * 
	 * This is a more strict version of `typeof x === 'object'` as this example would also succeeds for arrays and `null`.
	 * This function only returns `true` for real objects and not for arrays, `null` or any other data types.
	 * 
	 * @param {*} obj - A variable to check.
	 * @returns {boolean} - `true` is the given variable is an object, `false` otherwise.
	 */
	static isObject(obj) {
		return (typeof obj === 'object' && obj === Object(obj) && !Array.isArray(obj));
	}

	/**
	 * Checks whether a variable is a string and contains at least one character.
	 * 
	 * @param {*} string - A variable to check.
	 * @returns {boolean} - `true` is the given variable is an string with length > 0, `false` otherwise.
	 */
	static hasText(string) {
		return (typeof string === 'string' && string.length > 0);
	}

	/**
	 * Performs a deep comparison between two values to determine if they are equivalent.
	 * 
	 * @param {*} x - The value to compare.
	 * @param {*} y - The other value to compare.
	 * @returns {boolean} - Returns true if the values are equivalent, else false.
	 */
	static equals(x, y) {
		return equal(x, y);
	}

	/**
	 * Creates an object composed of the picked object properties.
	 * 
	 * Returns a shallow copy!
	 * 
	 * @param {object} obj - The source object.
	 * @param {string|array} toPick - The properties to pick.
	 * @returns {object}
	 */
	static pickFromObject(obj, toPick) {
		obj = Object(obj);
		if (typeof toPick === 'string') {
			toPick = [toPick];
		}
		const copy = {};
		toPick.forEach(key => copy[key] = obj[key]);
		return copy;
	}

	/**
	 * This method creates an object composed of the own and inherited enumerable property paths of object that are not omitted.
	 * 
	 * Returns a shallow copy!
	 * 
	 * @param {object} obj - The source object.
	 * @param {string|array} toOmit - The properties to omit.
	 * @returns {object}
	 */
	static omitFromObject(obj, toOmit) {
		obj = Object(obj);
		if (typeof toOmit === 'string') {
			toOmit = [toOmit];
		}
		var copy = Object.assign({}, obj);
		for(let key of toOmit) {
			delete copy[key];
		}
		return copy;
	}

	/**
	 *  Creates an array of values by running each property of `object` thru function.
	 * 
	 * The function is invoked with three arguments: (value, key, object).
	 * 
	 * @param {object} obj 
	 * @param {function} func 
	 * @returns {object}
	 */
	static mapObject(obj, func) {
		// Taken from lodash, see https://github.com/lodash/lodash/blob/master/mapObject.js
		const props = Object.keys(obj);
		const result = new Array(props.length);
		props.forEach((key, index) => {
			result[index] = func(obj[key], key, obj);
		});
		return result;
	}

	/**
	 * Creates an object with the same keys as object and values generated by running each own enumerable string keyed property of object thru the function.
	 * 
	 * The function is invoked with three arguments: (value, key, object).
	 * 
	 * @param {object} obj 
	 * @param {function} func 
	 * @returns {object}
	 */
	static mapObjectValues(obj, func) {
		// Taken from lodash, see https://github.com/lodash/lodash/blob/master/mapValue.js
		obj = Object(obj);
		const result = {};
		Object.keys(obj).forEach((key) => {
			result[key] = func(obj[key], key, obj);
		});
		return result;
	}

	/**
	 * Creates a duplicate-free version of an array.
	 * 
	 * If useEquals is set to true, uses the `Utils.equals` function for comparison instead of 
	 * the JS === operator. Thus, if the array contains objects, you likely want to set 
	 * `useEquals` to `true`.
	 * 
	 * @param {array} array
	 * @param {boolean} useEquals
	 * @returns {array}
	 */
	static unique(array, useEquals = false) {
		if (useEquals) {
			return array.filter((s1, pos, arr) => arr.findIndex(s2 => Utils.equals(s1, s2)) === pos);
		}
		else {
			return [...new Set(array)];
		}
	}
	
	/**
	 * Computes the size of an array (number of array elements) or object (number of key-value-pairs).
	 * 
	 * Returns 0 for all other data types.
	 * 
	 * @param {*} obj 
	 * @returns {integer}
	 */
	static size(obj) {
		if (typeof obj === 'object' && obj !== null) {
			if (Array.isArray(obj)) {
				return obj.length;
			}
			else {
				return Object.keys(obj).length;
			}
		}
		return 0;
	}

	/**
	 * Checks whether a variable is numeric.
	 * 
	 * Numeric is every string with numeric data or a number, excluding NaN and finite numbers.
	 * 
	 * @param {*} n - A variable to check.
	 * @returns {boolean} - `true` is the given variable is numeric, `false` otherwise.
	 */
	static isNumeric(n) {
		return !isNaN(parseFloat(n)) && isFinite(n);
    }
    
    /**
     * Deep clone for JSON-compatible data.
     * 
     * @param {*} x - The data to clone.
     * @returns {*} - The cloned data.
     */
    static deepClone(x) {
		return JSON.parse(JSON.stringify(x));
    }

	/**
	 * Normalize a URL (mostly handling leading and trailing slashes).
	 * 
	 * @static
	 * @param {string} baseUrl - The URL to normalize
	 * @param {string} path - An optional path to add to the URL
	 * @returns {string} Normalized URL.
	 */
	static normalizeUrl(baseUrl, path = null) {
		let url = baseUrl.replace(/\/$/, ""); // Remove trailing slash from base URL
		if (typeof path === 'string') {
			if (path.substr(0, 1) !== '/') {
				path = '/' + path; // Add leading slash to path
			}
			url = url + path.replace(/\/$/, ""); // Remove trailing slash from path
		}
		return url;
	}

	/**
	 * Replaces placeholders in this format: `{var}`.
	 * 
	 * This can be used for the placeholders/variables in the openEO API's errors.json file.
	 * 
	 * @param {string} message - The string to replace the placeholders in.
	 * @param {object} variables - A map with the placeholder names as keys and the replacement value as value.
	 */
	static replacePlaceholders(message, variables = {}) {
		if (typeof message === 'string' && Utils.isObject(variables)) {
			for(var placeholder in variables) {
				let vars = variables[placeholder];
				message = message.replace('{' + placeholder + '}', Array.isArray(vars) ? vars.join("; ") : vars);
			}
		}
		return message;
	}

	/**
	 * Compares two strings case-insensitive, including natural ordering for numbers.
	 * 
	 * @param {string} a 
	 * @param {string} b 
	 * @returns {integer} Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).
	 */
    static compareStringCaseInsensitive(a, b) {
        if (typeof a !== 'string') {
            a = String(a);
        }
        if (typeof b !== 'string') {
            b = String(b);
        }
        return a.localeCompare(b, undefined, {numeric: true, sensitivity: 'base'});
    }

	/**
	 * Tries to make a string more readable by capitalizing it.
	 * Only applies to words with more than two characters.
	 * 
	 * Supports converting from:
	 * - Snake Case (abc_def => Abc Def)
	 * - Kebab Case (abc-def => Abc Def)
	 * - Camel Case (abcDef => Abc Def)
	 * 
	 * Doesn't capitalize if the words are not in any of the casing formats above.
	 * 
	 * @param {*} strings - String(s) to make readable
	 * @param {string} arraySep - String to separate array elements with
	 * @returns {string}
	 */
    static prettifyString(strings, arraySep = '; ') {
		if (!Array.isArray(strings)) {
			strings = [String(strings)];
		}
		strings = strings.map(str => {
			if (str.length >= 3) {
				const replacer = (_,a,b) => a + ' ' + b.toUpperCase();
				if (str.includes('_')) {
					// Snake case converter
					str = str.replace(/([a-zA-Z\d])_([a-zA-Z\d])/g, replacer);
				}
				else if (str.includes('-')) {
					// Kebab case converter
					str = str.replace(/([a-zA-Z\d])-([a-zA-Z\d])/g, replacer);
				}
				else {
					// Camelcase converter
					str = str.replace(/([a-z])([A-Z])/g, replacer);
				}
				// Uppercase the first letter in the first word, too.
				return str.charAt(0).toUpperCase() + str.substr(1);
			}
			return str;
		});
		return strings.join(arraySep);	
    }

	/**
	 * Makes link lists from the openEO API more user-friendly.
	 * 
	 * Supports:
	 * - Set a reasonable title, if not available. Make title more readable.
	 * - Sorting by title (see `sort` parameter)
	 * - Removing given relation types (`rel` property, see `ignoreRel` parameter)
	 * 
	 * @param {array} linkList - List of links
	 * @param {boolean} sort - Enable/Disable sorting by title. Enabled (true) by default.
	 * @param {array} ignoreRel - A list of rel types to remove. By default, removes the self links (rel type = `self`).
	 * @returns {array}
	 */
    static friendlyLinks(linkList, sort = true, ignoreRel = ['self']) {
        let links = [];
        if (!Array.isArray(linkList)) {
            return links;
        }

        for(let link of linkList) {
            link = Object.assign({}, link); // Make sure to work on a copy
            if (typeof link.rel === 'string' && ignoreRel.includes(link.rel.toLowerCase())) {
                continue;
            }
            if (typeof link.title !== 'string' || link.title.length === 0) {
                if (typeof link.rel === 'string' && link.rel.length > 1) {
                    link.title = Utils.prettifyString(link.rel);
                }
                else {
                    link.title = link.href.replace(/^https?:\/\/(www.)?/i, '').replace(/\/$/i, '');
                }
            }
            links.push(link);
        }
        if (sort) {
            links.sort((a, b) => Utils.compareStringCaseInsensitive(a.title, b.title));
        }
        return links;
    }

}

module.exports = Utils;

/***/ }),

/***/ 855:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { compare, compareVersions, validate } = __webpack_require__(385);

/** Version Number related methods */
class Versions {

	/**
	 * Compare [semver](https://semver.org/) version strings.
	 * 
	 * @param {string} firstVersion First version to compare
	 * @param {string} secondVersion Second version to compare
	 * @param {string|null} operator Optional; Arithmetic operator to use (>, >=, =, <=, <, !=). Defaults to `null`.
	 * @returns {boolean|integer} If operator is not `null`: true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise. If operator is `null`: Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).
	 * ```
	 */
	static compare(v1, v2, operator = null) {
		if (operator !== null) {
			return compare(v1, v2, operator);
		}
		else {
			return compareVersions(v1, v2);
		}
	}

	/**
	 * Validate [semver](https://semver.org/) version strings.
	 * 
	 * @param {*} version - Version number to validate
	 * @returns - `true` if the version number is a valid semver version number, `false` otherwise.
	 */
	static validate(version) {
		return validate(version);
	}

	/**
	 * Tries to determine the most suitable version from a well-known discovery document that software is compatible to.
	 * 
	 * @static
	 * @param {array} wkVersions - A well-known discovery document compliant to the API specification.
	 * @param {boolean} preferProduction - Set to `false` to make no difference between production and non-production versions.
	 * @param {string|null} minVersion - The minimum version that should be returned.
	 * @param {string|null} maxVersion - The maximum version that should be returned.
	 * @returns {object[]} - Gives a list that lists all compatible versions (as still API compliant objects) ordered from the most suitable to the least suitable.
	 */
	static findCompatible(wkVersions, preferProduction = true, minVersion = null, maxVersion = null) {
		if (!Array.isArray(wkVersions) || wkVersions.length === 0) {
			return [];
		}

		let compatible = wkVersions.filter(c => {
			if (typeof c.url === 'string' && Versions.validate(c.api_version)) {
				let hasMinVer = Versions.validate(minVersion);
				let hasMaxVer = Versions.validate(maxVersion);
				if (hasMinVer && hasMaxVer) {
					return Versions.compare(c.api_version, minVersion, ">=") && Versions.compare(c.api_version, maxVersion, "<=");
				}
				else if (hasMinVer) {
					return Versions.compare(c.api_version, minVersion, ">=");
				}
				else if (hasMaxVer) {
					return Versions.compare(c.api_version, maxVersion, "<=");
				}
				else {
					return true;
				}
			}
			return false;
		 });
		if (compatible.length === 0) {
			return [];
		}

		return compatible.sort((c1, c2) => {
			let p1 = c1.production === true;
			let p2 = c2.production === true;
			if (!preferProduction || p1 === p2) {
				return Versions.compare(c1.api_version, c2.api_version) * -1; // `* -1` to sort in descending order.
			}
			else if (p1) {
				return -1;
			}
			else {
				return 1;
			}
		});
	}

	/**
	 * Find the latest version from well-known discovery that applies to the specified rules.
	 * 
	 * This is basically the same as calling `findCompatible` and using the first element from the result.
	 * 
	 * @param {array} wkVersions - A well-known discovery document compliant to the API specification.
	 * @param {boolean} preferProduction - Set to `false` to make no difference between production and non-production versions.
	 * @param {string|null} minVersion - The minimum version that should be returned.
	 * @param {string|null} maxVersion - The maximum version that should be returned.
	 * @returns {object|null}
	 */
	static findLatest(wkVersions, preferProduction = true, minVersion = null, maxVersion = null) {
		let versions = Versions.findCompatible(wkVersions, preferProduction, minVersion, maxVersion);
		if (versions.length > 0) {
			return versions[0];
		}
		else {
			return null;
		}
	}
	
}

module.exports = Versions;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(803);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});